#+TITLE: Transducers
# Tags #clojure

https://dev.solita.fi/2021/10/14/grokking-clojure-transducers.html

** Reducing function
Defn: Something that can be used by reduce, ie takes a collection and an item and returns a collection

** Transducer
Takes a reducing function and returns another reducing function ie.
#+begin_src clojure
(defn inc-transducer
  "Given a reducing function rf, return a new reducing function that increments
  every input it receives, then calls rf with the result and the incremented
  input."
  ;; rf stands for "reducing function"
  [rf]
  ;; this here's a new reducing function
  (fn [result input]
    ;; here we call the original reducing function
    (rf result (inc input))))

(def inc-then-conj (inc-transducer conj))
;;=> #'user/inc-then-conj
(inc-then-conj [1 2] 3)
;;=> [1 2 4]

(reduce inc-then-conj [] [1 2 3 4 5])
;;=> [2 3 4 5 6]

(reduce (inc-transducer +) 0 [1 2 3 4 5])
;;=> 20
#+end_src

Could be used to re-implement map, with the addition of the ability to change the underlying function. map uses conj to collect the output.

#+begin_src clojure
(defn mapping
  "Given function f, return a transducer that calls f on every input it
  receives."
  [f]
  (fn [rf]
    (fn [result input]
      (rf result (f input)))))

(def inc-mapper
  "Given a reducing function rf, return a reducing function that increments its
  input before calling rf."
  (mapping inc))

(def inc-rf
  "A reducing function that increments its input, then adds it into the
  accumulated result."
  (inc-mapper conj))

(reduce inc-rf [] [1 2 3 4 5])
;;=> [2 3 4 5 6]

(defn filtering
  "Given a predicate function pred, return a transducer that only retains items
  for which pred returns true."
  [pred]
  (fn [rf]
    (fn [result input]
      (if (pred input)
        (rf result input)
        result))))

(def rf
  "A reducing function that filters even numbers, increments every remaining
  number, then conjoins them into the result."
  ((comp (filtering even?) (mapping inc)) conj))

(reduce rf [] [1 2 3 4 5])
;;=> [3 5]
#+end_src

inc-rf does much the same as (map inc ...)
and rf is doing much the same as (--> ...)
These achieve the same end but the first is building a single function using comp that runs one on each item in the collection rather than each function running in turn on thecollection or intermediate collection as it passes through the threading. This is potentially faster if the list and the threading are long.
#+begin_src clojure
  (,,,
   (comp
     (filtering even?)
     (mapping inc))
   ,,,)

  (->>
    [1 2 3 4 5]
    (filter even?)
    (map inc))
#+end_src

Even simpler we don't have to define mapping. Using map and not giving it a second param returns a transducer. This does the same thing:
#+begin_src clojure
  (reduce
    ((comp (filter even?) (map inc)) conj) ;; <- reducing fn (awesome conj)
    [] ;; <- initial value
    [1 2 3 4 5] ;; <- input collection
    )
  ;;=> [3 5]
#+end_src

 BUT: avoid reduce, use *transduce* with transducers instead. Note the subtle difference in the comp callie one less set of parens
#+begin_src clojure
(transduce
  (comp (filter even?) (map inc))
  conj
  []
  [1 2 3 4 5])
;;=> [3 5]
#+end_src

** Sequence
Uses transducers to create a lazy list and caches the results as they are used
#+begin_src clojure
(def xs
  (sequence
    (comp (filter even?) (map inc))
    (range 100)))

;; in one case, we might need to take the first ten things from `xs`
(take 10 xs)
;;=> (1 3 5 7 9 11 13 15 17 19)

;; later, in another context, we might need to take just the first five numbers
(take 5 xs)
;;=> (1 3 5 7 9)
#+end_src
In the second call the values are read from the cache stored when the first call is made
** Eduction
No caching here. The eduction stores the collection but doesn't run the functions on it until it is called. Runs the functions every time it is called:
#+begin_src clojure
;; Create a transformation that filters the even numbers between 0 and 99 and
;; increments the remaining numbers.
;;
;; Don't transform anything just yet, though.
(def xf
  (eduction
    (comp (filter even?) (map inc))
    (range 100)))

;; Apply the eduction to sum the transformed numbers.
(reduce + 0 xf)
;;=> 2500

;; Apply the eduction to multiply each number by ten, then add them into a hash
;; set.
(reduce (fn [s n] (conj s (* n 10))) #{} xf)
;;=> #{950 530 410 970 70 430 370 110 ...}
#+end_src
TODO find out if this should really be using transduce instead of reduce

Another blog mentioning use of transducers:
https://bsless.github.io/fast-and-elegant-clojure/
